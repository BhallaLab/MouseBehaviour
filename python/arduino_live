#!/usr/bin/env python2
"""arduino_live.py: 

    Read the data from serial port and plot it using FuncAnimation from
    matplotlib.

"""
from __future__ import print_function
    
__author__           = "Dilawar Singh, Ananthamurhty, and Shriya P"
__copyright__        = "Copyright 2015, Bhalla lab, NCBS Bangalore"
__credits__          = ["NCBS Bangalore"]
__license__          = "GNU GPL"
__version__          = "1.0.0"
__maintainer__       = __author__
__email__            = "dilawars@ncbs.res.in"
__status__           = "Development"

import config
import arduino 
import os
import sys
import time
import readchar

from collections import defaultdict
import datetime
import csv
import numpy as np
import codecs
import Queue
from threading import Thread, Lock
import gnuplotlib as gp
import logging

_logger = logging.getLogger('')

running_data_line_ = 0
total_trials_ = 0

select_sent_ = False

# Our shared queue used in multiprocessing
q_ = Queue.Queue()
running_trial_ = 0
finished_all_ = 0


def cleanup():
    pass

def init_serial( baudRate = 38400):
    if config.args_.port is None:
        config.args_.port = arduino.get_default_serial_port( )
    print("[INFO] Using port: %s" % config.args_.port)
    config.serial_port_ = arduino.ArduinoPort( config.args_.port, baudRate )
    config.serial_port_.open( wait = True )
   
def writeTrialData( runningTrial, csType ):
    #The first line after '@' will give us
    outfile = os.path.join( config.save_dir_, 'Trial%s.csv' % runningTrial )
    print("[INFO] Writing trial data to : %s" % outfile)
    with open(outfile, 'w') as f:
        f.write("# 3rd row values are trial index, cs type.\n")
        f.write("# Actual trial data starts from row 4\n")
        f.write( "%s,%s\n" % (runningTrial, csType))
        print('\t Total entries = %s' % len(config.trial_dict_[runningTrial]))
        for (blinkValue, timeStamp) in config.trial_dict_[runningTrial]:
            f.write("%s,%s\n" % (blinkValue, timeStamp))

def send_press_select( reftime, interval ):
    if time.time() - reftime < interval:
        return False
    print('[INFO] Sending SELECT to board')
    config.serial_port_.write_msg("ss\r")
    time.sleep(0.5)
    print('[INFO] Waiting for Board to respond .', end='')
    sys.stdout.flush()
    while '>>>Recieved' not in config.serial_port_.read_line():
        print('.', end='')
        sys.stdout.flush()
    return True

def print_line( line, lock ):
    global running_data_line_
    ds = line.split(',')
    if len(ds) != 4:
        return 
    hline = '-'.join([ '' for x in range( min(80, int(ds[1])/10) ) ])
    # Only print if running data line is multiple of 10
    if running_data_line_ % 20 == 0:
        lock.acquire()
        print("%3s - %10s\n" % (line, hline ))
        lock.release()

def collect_data( lock ):
    global q_
    global running_data_line_
    global total_trials_
    global running_trial_
    tstart = time.time()
    runningTrial = 0
    while True:
        running_data_line_ += 1
        line = config.serial_port_.read_line( )
        x, y, trialNum, totalTrials, cs = line_to_data( line )
        total_trials_ = totalTrials
        if (x and y) is None:
            continue

        try:
            x, y = int(x), int(y)
            q_.put((y,x))
            config.trial_dict_[runningTrial].append((y,x))
        except Exception as e:
            pass

        # Valid trial has started.
        if trialNum != 0:
            break
        # All right. If we are here then we are waiting for SELECT to be
        # pressed. Let's press is by sending three ` to serialport after
        # some timeout.
        if send_press_select( tstart, config.args_.select_after ):
            lock.acquire()
            print("SELECT sent")
            lock.release()
            break

    # Either we have pressed the SELECT or we have sent the select command ss
    select_sent_ = True
    _logger.info('Out of first loop.')
    while True:
        if finished_all_ == 1:
            return None

        running_data_line_ += 1
        running_trial_ = runningTrial
        line = config.serial_port_.read_line()
        x, y, trialNum, totalTrials, cs = line_to_data(line)
        total_trials_ = totalTrials
        print_line( line, lock )
        if (x and y) is None:
            continue
        config.trial_dict_[runningTrial].append((y,x))
        q_.put((y,x))
        if trialNum > runningTrial:
            print('[INFO] New trial: Trial :%s/%s, cs: %s' % (trialNum,
                totalTrials, cs))
            writeTrialData( runningTrial, cs )
            runningTrial = trialNum

def line_to_data( line ):
    if not line.strip():
        return [None]*5
    try:
        t, v, trial_num, totalTrials, cs = line.split(',')
    except Exception as e:
        _logger.info("Invalid data line: %s" % line)
        return [None]*5
    try:
        t, v, trial_num, totalTrials, cs = int(t), int(v), int(trial_num), int(totalTrials), int(cs)
    except Exception as e:
        t, v, trial_num, totalTrials, cs = [None]*5
    
    return t, v, trial_num, totalTrials, cs

def init_gui():
    config.text_.set_text('')
    return config.gline_, config.gline1_, config.text_

def plot_data( lock ):
    global q_
    global running_trial_
    global total_trials_
    ptstart = time.time()
    while True:
        if finished_all_ == 1:
            return None
        # Queue can become empty in ITI sessions.
        qsize = q_.qsize( )
        if qsize < 20:
            _logger.info('Queue  size less than 20')
            continue
        # Get some elements from queue and plot them.
        for i in range(10):
            d = q_.get()
            config.ybuff_.append( int(d[0]) )
        
        title = '%s %2.2f, Mouse: %s, Trial: %2d/%3d' % (  config.args_.port
                , time.time() - ptstart 
                , config.args_.name
                , running_trial_
                , total_trials_
                )

        gp.plot( np.asarray(config.ybuff_[-2000:]) 
                , title = title
                , terminal = 'x11'
                , yrange = '200:800'
                )

def answer_three_questions( ):
    # All great UI has three questions. Yes we have to, they all starts with
    # Please.
    questionsAnswered = [ ]
    for i in range( 20 ):
        l = arduino.read_until('?? Please enter', timeout = 1)
        if 'mouse ID number' in l:
            print('[ANSW] %s = %s' % (l, config.args_.name))
            config.serial_port_.write_msg('%s\r' % config.args_.name )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        elif 'session type' in l:
            print('[ANSW] %s = %s' % (l, config.args_.session_type))
            config.serial_port_.write_msg( '%s\r' % config.args_.session_type )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        elif 'session number' in l:
            print('[ANSW] %s = %s' % (l, config.args_.session_num))
            config.serial_port_.write_msg('%s\r' % config.args_.session_num )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        else:
                pass

        if len(questionsAnswered) == 3:
            print('[INFO] All questions are answered')
            return 


def init( ):
    """
    Wait for first three questions to appear which requires writing to serial
    port. If serial port is sending legal data then continue, questions are
    probably answered.
    """

    # Get 3 from arduino, and check if arduino is sending legal data or
    # just waiting for questions to be answered.
    for i in range(3):
        l = config.serial_port_.read_line( )
        while not l:
            l = config.serial_port_.read_line( )
        if 'Please enter' in l:
            # mere sawalo ka jawav do... do naa!
            answer_three_questions( )
            break
        # If valid data is found in lines (trial is more than 1) then don't ask
        # questions and quit immediately
        else:
            data = line_to_data( l )
            if data[2] is not None:
                if data[2] >= 0:
                    break

    timeStamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    mouseName = 'MouseK%s' % config.args_.name
    outfile = os.path.join( mouseName
            , 'MouseK%s_SessionType%s_Session%s' % ( 
                config.args_.name, config.args_.session_type, config.args_.session_num)
            )
    config.save_dir_ = os.path.join( config.save_dir_, outfile )
    if os.path.exists(config.save_dir_):
        config.save_dir_ = os.path.join(config.save_dir_, timeStamp)
        os.makedirs(config.save_dir_)
    else:
        os.makedirs(config.save_dir_) 

def send_command( ):
    # all commands should be two characters long
    global select_sent_
    global finished_all_
    command = ""
    validCommands = [ "++", "--", "pp", "ss", "rr" ]
    validStartChars = ''.join([ x[0] for x in validCommands ])
    while True:
        # Do not send any command if select button is send or we are in second
        # loop.
        k = readchar.readkey()
        if k in validStartChars:
            command += k
            if command in validCommands[0:-2] and not select_sent_:
                print("[COMMAND] Sending command: %s" % command)
                config.serial_port_.write_msg( command )
                command = ""
            # Last two commands needs to be handled separately.
            elif command == 'ss' and not select_sent_:
                select_sent_ = True
                config.serial_port_.write_msg( command )
            elif command == 'rr':
                # reboot. 
                print("[WARN] Reboot in 2 seconds. You have to relaunch the")
                print("       app")
                config.serial_port_.write_msg( command )
                finished_all_ = 1
                cleanup()
                return None
            else:
                pass
            if len(command) == 2:
                command = ""
        elif k in [ '\x03', '\x04', '\x1a' ]:
            finished_all_ = 1
            raise KeyboardInterrupt

def main( ):
    init( )

    # Lock so that only one process prints to console at a time.
    l = Lock( ) 

    # When daemon is set to True, all threads will exit (ungracefully) when main
    # terminates.
    collectProcess = Thread( target = collect_data, args=(l,))
    collectProcess.daemon = True
    plotProcess = Thread( target = plot_data, args=(l,))
    plotProcess.daemon = True

    collectProcess.start()
    plotProcess.start()

    plotProcess.join( timeout = 1 )
    collectProcess.join( timeout = 1 )

    send_command( )

if __name__ == '__main__':
    import argparse
    # Argument parser.
    description = '''Animate arduino data from serial port'''
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('--name', '-n'
        , required = True
        , type = int
        , help = 'Mouse index (positive integers)'
        )
    parser.add_argument('--session-type', '-st'
        , required = True
        , type = int
        , help = 'Seession Type [0,1,2]'
        )
    parser.add_argument('--session-num', '-sn'
        , required = True
        , type = int
        , help = 'Session number (positive integer)'
        )
    parser.add_argument('--port', '-p'
        , required = False
        , default = None
        , help = 'Serial port [full path]'
        )
    parser.add_argument('--select_after', '-sa'
        , required = False
        , default = 60000000.0
        , type = float
        , help = 'Press SELECT after time. Default 600 sec.'
        )
    parser.parse_args( namespace = config.args_ )
    init_serial()
    try:
        main( )
    except KeyboardInterrupt as e:
        print("[WARN] Interrupt from keyboard.... Quitting after cleanup.")
        cleanup()
        quit()
