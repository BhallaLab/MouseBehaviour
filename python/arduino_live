#!/usr/bin/env python2
"""arduino_live.py: 

    Read the data from serial port and plot it using FuncAnimation from
    matplotlib.

"""
    
__author__           = "Dilawar Singh, Ananthamurhty, and Shriya P"
__copyright__        = "Copyright 2015, Bhalla lab, NCBS Bangalore"
__credits__          = ["NCBS Bangalore"]
__license__          = "GNU GPL"
__version__          = "1.0.0"
__maintainer__       = __author__
__email__            = "dilawars@ncbs.res.in"
__status__           = "Development"

from __future__ import print_function
from config import *
from arduino import ArduinoPort

import os
import sys
import time

from collections import defaultdict
import datetime
import csv
import numpy as np
import codecs
from multiprocessing  import Process, Queue, Value
import matplotlib.pyplot as plt
from matplotlib import animation
import logging

def cleanup():
    pass

def get_default_serial_port( ):
    # If port part is not given from command line, find a serial port by
    # default.
    print("[WARN] Searching for ARDUINO port since no --port/-p is given")
    print("       Only listing ports with VENDOR ID ")
    coms = list(serial.tools.list_ports.grep( 'PID' ))
    return coms[-1][0]

def init_serial( baudRate = 9600):
    global serial_port_
    global args_
    
    if args_.port is None:
        args_.port = get_default_serial_port( )
    print("[INFO] Using port: %s" % args_.port)
    serial_port_ = ArduinoPort( args_.port, baudRate )
    serial_port_.open( wait = True )
   
def writeTrialData( runningTrial, csType ):
    #The first line after '@' will give us
    global save_dir_
    global trial_dict_
    
    outfile = os.path.join( save_dir_, 'Trial%s.csv' % runningTrial )
    print("[INFO] Writing trial data to : %s" % outfile)
    with open(outfile, 'w') as f:
        f.write("# 3rd row values are trial index, cs type.\n")
        f.write("# Actual trial data starts from row 4\n")
        f.write( "%s,%s\n" % (runningTrial, csType))
        for (blinkValue, timeStamp) in trial_dict_[runningTrial]:
            f.write("%s,%s\n" % (blinkValue, timeStamp))

def collect_data( ):
    global serial_port_
    global trial_dict_
    global running_trial_
    global cur_

    # Used to ignore garbage data in the begining.
    anyTrialHasStarted = False
    runningTrial = 0
    csType = None
    while True:
        arduinoData = serial_port_.read_line()
        y, x = line_to_yx(arduinoData)
        if x is not None and y is not None:
            q_.put((y,x))

        if not arduinoData:
            continue

        # When TRIAL_DATA_MARKER is found, collect trial data and write the
        # previous non-zero trial.
        if TRIAL_DATA_MARKER in arduinoData:
            anyTrialHasStarted = True
            print("[INFO] New trial starts")
            runningTrial += 1
            # global copy for display on matplotlib
            running_trial_.value = runningTrial  
            if int(runningTrial) >= 2:
                print("[INFO] Writing previous trial %s" % ( int(runningTrial) - 1 ))
                writeTrialData( runningTrial - 1, csType )
                # Reset csType to None
                csType = None
        elif anyTrialHasStarted:
            if not csType:
                runningTrial, csType = arduinoData.split()
                runningTrial = int(runningTrial)
                print("[INFO] Trial: %s, CSType: %s" % (runningTrial, csType))
            else:
                if x and y:
                    trial_dict_[runningTrial].append((y,x))
                
        else:
            pass

def read_until( msg ):
    global serial_port_
    while True:
        line = serial_port_.read_line()
        if msg.lower() in line.lower():
            print("%s ...  Found" % line)
            return True

def init_arduino():
    global serial_port_
    global save_dir_
    global args_

    print("[INFO] Waiting for questions to appear")
    read_until('#Please enter')
    serial_port_.write_msg('%s\r' % args_.name )
    time.sleep(1)

    read_until('#Please enter')
    serial_port_.write_msg( '%s\r' % args_.session_type )
    time.sleep(1)

    read_until('#Please enter')
    serial_port_.write_msg('%s\r' % args_.session_num )
    time.sleep(1)

    timeStamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    mouseName = 'MouseK%s' % args_.name
    outfile = os.path.join( mouseName
            , '%s_SessionType%s_Session%s' % ( 
                args_.name, args_.session_type, args_.session_num)
            )
    save_dir_ = os.path.join( save_dir_, outfile )
    if os.path.exists(save_dir_):
        save_dir_ = os.path.join(save_dir_, timeStamp)
        os.makedirs(save_dir_)
    else:
        os.makedirs(save_dir_) 

def line_to_yx( line ):
    if not line.strip():
        return (None, None)
    l = line.split()
    if not l:
        return (None, None)
    if len(l) == 1: 
        l.append( 0 )
    try:
        return (float(l[0]), float(l[1]))
    except Exception as e:
        return (None, None)
    return l


def init():
    text_.set_text('')
    return gline_, gline1_, text_

def animate(i):
    global xbuff_, ybuff_
    global q_
    global running_trial_
    global args_

    # Get 20 elements from queue and plot them.
    if q_.qsize() < 10:
        return gline_, gline1_, text_

    for i in range(10):
        d = q_.get()
        ybuff_.append( d[0] )
        xbuff_.append( xbuff_[-1] + 1 )

    _logger.debug("Got from queue: %s, %s" % (xbuff_[-10:], ybuff_[-10:]))
    xmin, xmax = gax_.get_xlim()
    if xbuff_[-1] >= xmax:
        _logger.info("Updating axes")
        gax_.set_xlim((xmin+1000, xmax+1000))
        # This is real data (last 3000 points).
        stary_.append(50)
        # Its the location of stars
        startx_.append(xbuff_[-1])
        gline1_.set_data(startx_, stary_)
        xbuff_ = xbuff_[-5000:]
        ybuff_ = ybuff_[-5000:]

    gline_.set_data(xbuff_[-3000:], ybuff_[-3000:])
    text = 'TIME: %.3f' % (time.time() - tstart)
    text += ' MOUSE: %s' % args_.name
    text += ' SERIAL: %s' % args_.port
    text += ' TRIAL: %d' % running_trial_.value
    text_.set_text(text)
    return gline_, gline1_, text

def main():
    global args_
    init_arduino( )
    p = Process( target = collect_data )
    p.start()
    anim = animation.FuncAnimation(fig_
            , animate
            , init_func = init
            , frames=1
            , interval = 1
            , blit = False
            )
    plt.show()
    p.join()

if __name__ == '__main__':
    import argparse
    # Argument parser.
    description = '''Arduino reader.'''
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('--name', '-n'
        , required = True
        , type = int
        , help = 'Mouse index (positive integers)'
        )
    parser.add_argument('--session-type', '-st'
        , required = True
        , type = int
        , help = 'Seession Type [0,1,2]'
        )
    parser.add_argument('--session-num', '-sn'
        , required = True
        , type = int
        , help = 'Session number (positive integer)'
        )
    parser.add_argument('--port', '-p'
        , required = False
        , default = None
        , help = 'Serial port [full path]'
        )
    class Args: pass 
    args_ = Args()
    parser.parse_args( namespace=args_ )
    init_serial()
    # Each serial port gets its own logger.
    logging.basicConfig(level=logging.DEBUG,
            format='%(asctime)s -- %(message)s',
            datefmt='%m-%d %H:%M',
            filename='blink_%s.log' % (args_.port.split('/')[-1]),
            filemode='w')
    _logger = logging.getLogger('')
    try:
        main( )
    except KeyboardInterrupt as e:
        print("[WARN] Interrupt from keyboard.... Quitting after cleanup.")
        cleanup()
        quit()
