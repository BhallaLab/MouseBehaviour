#!/usr/bin/env python2
"""arduino_live.py: 

    Read the data from serial port and plot it using FuncAnimation from
    matplotlib.

"""
from __future__ import print_function
    
__author__           = "Dilawar Singh, Ananthamurhty, and Shriya P"
__copyright__        = "Copyright 2015, Bhalla lab, NCBS Bangalore"
__credits__          = ["NCBS Bangalore"]
__license__          = "GNU GPL"
__version__          = "1.0.0"
__maintainer__       = __author__
__email__            = "dilawars@ncbs.res.in"
__status__           = "Development"

import config
from config import _logger
import arduino 
import os
import sys
import time


from collections import defaultdict
import datetime
import csv
import numpy as np
import codecs
from multiprocessing  import Process, Queue, Value
import matplotlib.pyplot as plt
from matplotlib import animation

def cleanup():
    pass

def init_serial( baudRate = 38400):
    if config.args_.port is None:
        config.args_.port = arduino.get_default_serial_port( )
    print("[INFO] Using port: %s" % config.args_.port)
    config._logger.set_name( 'eyeblink_%s' % (config.args_.port.split('/')[-1]))
    config.serial_port_ = arduino.ArduinoPort( config.args_.port, baudRate )
    config.serial_port_.open( wait = True )
   
def writeTrialData( runningTrial, csType ):
    #The first line after '@' will give us
    outfile = os.path.join( config.save_dir_, 'Trial%s.csv' % runningTrial )
    print("[INFO] Writing trial data to : %s" % outfile)
    with open(outfile, 'w') as f:
        f.write("# 3rd row values are trial index, cs type.\n")
        f.write("# Actual trial data starts from row 4\n")
        f.write( "%s,%s\n" % (runningTrial, csType))
        print('\t Total entries = %s' % len(config.trial_dict_[runningTrial]))
        for (blinkValue, timeStamp) in config.trial_dict_[runningTrial]:
            f.write("%s,%s\n" % (blinkValue, timeStamp))

def send_press_select( reftime, interval ):
    if time.time() - reftime < interval:
        return False
    print('[INFO] Sending SELECT to board')
    config.serial_port_.write_msg("```\r")
    time.sleep(0.5)
    print('[INFO] Waiting for Board to respond .', end='')
    sys.stdout.flush()
    while '>>>Recieved' not in config.serial_port_.read_line():
        print('.', end='')
        sys.stdout.flush()
    return True

def collect_data( ):
    anyTrialHasStarted = False
    runningTrial = 0
    csType = None
    tstart = time.time()
    while True:
        arduinoData = config.serial_port_.read_line()
        y, x = line_to_yx(arduinoData)
        if config.TRIAL_DATA_MARKER in arduinoData:
            anyTrialHasStarted = True
            runningTrial += 1
            config.running_trial_.value = runningTrial
            break
        if (x and y) is not None:
            config.q_.put((y,x))
        # All right. If we are here then we are waiting for SELECT to be
        # pressed. Let's press is by sending three ` to serialport after
        # some timeout.
        if send_press_select( tstart, config.args_.select_after ):
            print("SELECT sent")
            break
    _logger.log('Out of first loop.')
    while True:
        arduinoData = config.serial_port_.read_line()
        y, x = line_to_yx(arduinoData)
        if (x and y) is not None:
            config.q_.put((y,x))

        # When TRIAL_DATA_MARKER is found, collect trial data and write the
        # previous non-zero trial.
        if config.TRIAL_DATA_MARKER in arduinoData:
            anyTrialHasStarted = True
            print("[INFO] New trial starts")
            runningTrial += 1
            # global copy for display on matplotlib
            config.running_trial_.value = runningTrial  
            if int(runningTrial) >= 2:
                print("[INFO] Writing previous trial %s" % ( int(runningTrial) - 1 ))
                writeTrialData( runningTrial - 1, csType )
                # Reset csType to None
                csType = None
        elif anyTrialHasStarted:
            if not csType:
                runningTrial, csType = arduinoData.split()
                runningTrial = int(runningTrial)
                print("[INFO] Trial: %s, CSType: %s" % (runningTrial, csType))
            else:
                if x and y:
                    config.trial_dict_[runningTrial].append((y,x))

def line_to_yx( line ):
    if not line.strip():
        return (None, None)
    l = filter(None, line.split())
    if not l:
        return (None, None)
    if len(l) == 1: 
        l.append( -1 )
    try:
        return (float(l[0]), float(l[1]))
    except Exception as e:
        return (None, None)
    return l

def init_gui():
    config.text_.set_text('')
    return config.gline_, config.gline1_, config.text_

def animate(i):

    gax_ = config.gax_
    gline1_ = config.gline1_
    gline_ = config.gline_
    text_ = config.text_

    # Queue can become empty in ITI sessions.
    qsize = config.q_.qsize( )
    if qsize < 10:
        _logger.log('Queue  size less than 10')
        return gline_, gline1_, text_
    # Get some elements from queue and plot them.
    for i in range(10):
        d = config.q_.get()
        config.ybuff_.append( d[0] )
        config.xbuff_.append( config.xbuff_[-1] + 1 )

    #config._logger.log("Got from queue: %s, %s" % (
    #    config.xbuff_[-10:], config.ybuff_[-10:])
    #    )

    xmin, xmax = gax_.get_xlim()
    if config.xbuff_[-1] >= xmax:
        config._logger.log("Updating axes")
        gax_.set_xlim((xmin+1000, xmax+1000))
        # This is real data (last 3000 points).
        config.stary_.append(50)
        # Its the location of stars
        config.startx_.append(config.xbuff_[-1])
        gline1_.set_data(config.startx_, config.stary_)
        config.xbuff_ = config.xbuff_[-5000:]
        config.ybuff_ = config.ybuff_[-5000:]

    gline_.set_data(config.xbuff_[-3000:], config.ybuff_[-3000:])
    text = 'Port: %s' % config.args_.port
    text += '@ %.2f sec\n' % (time.time() - config.tstart)
    text += 'Mouse: %s' % config.args_.name
    text += ' Trial: %d' % config.running_trial_.value
    text_.set_text(text)
    return gline_, gline1_, text_

def answer_three_questions( ):
    # All great UI has three questions. Yes we have to, they all starts with
    # Please.
    questionsAnswered = [ ]
    for i in range( 20 ):
        l = arduino.read_until('Please enter', timeout = 0.5)
        if 'mouse ID number' in l:
            print('[ANSW] %s = %s' % (l, config.args_.name))
            config.serial_port_.write_msg('%s\r' % config.args_.name )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        elif 'session type' in l:
            print('[ANSW] %s = %s' % (l, config.args_.session_type))
            config.serial_port_.write_msg( '%s\r' % config.args_.session_type )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        elif 'session number' in l:
            print('[ANSW] %s = %s' % (l, config.args_.session_num))
            config.serial_port_.write_msg('%s\r' % config.args_.session_num )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        else:
                pass

        if len(questionsAnswered) == 3:
            print('[INFO] All questions are answered')
            return 


def init( ):
    """
    Wait for first three questions to appear which requires writing to serial
    port. If serial port is sending legal data then continue, questions are
    probably answered.
    """

    # Get 3 lines from arduino, and check if arduino is sending legal data or
    # just waiting for questions to be answered.
    lines = []
    for i in range(3):
        l = config.serial_port_.read_line( )
        if 'Please enter' in l:
            # mere sawalo ka jawav do... do naa!
            answer_three_questions( )
            break

    timeStamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    mouseName = 'MouseK%s' % config.args_.name
    outfile = os.path.join( mouseName
            , 'Mouse%s_SessionType%s_Session%s' % ( 
                config.args_.name, config.args_.session_type, config.args_.session_num)
            )
    config.save_dir_ = os.path.join( config.save_dir_, outfile )
    if os.path.exists(config.save_dir_):
        config.save_dir_ = os.path.join(config.save_dir_, timeStamp)
        os.makedirs(config.save_dir_)
    else:
        os.makedirs(config.save_dir_) 

def main( ):
    init( )
    p = Process( target = collect_data )
    p.start()
    anim = animation.FuncAnimation(
            config.fig_
            , animate
            , init_func = init_gui
            , frames = 1
            , interval = 1
            , blit = True
            )
    plt.show()
    p.join()

if __name__ == '__main__':
    import argparse
    # Argument parser.
    description = '''Animate arduino data from serial port'''
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('--name', '-n'
        , required = True
        , type = int
        , help = 'Mouse index (positive integers)'
        )
    parser.add_argument('--session-type', '-st'
        , required = True
        , type = int
        , help = 'Seession Type [0,1,2]'
        )
    parser.add_argument('--session-num', '-sn'
        , required = True
        , type = int
        , help = 'Session number (positive integer)'
        )
    parser.add_argument('--port', '-p'
        , required = False
        , default = None
        , help = 'Serial port [full path]'
        )
    parser.add_argument('--select_after', '-sa'
        , required = False
        , default = 60000000.0
        , type = float
        , help = 'Press SELECT after time. Default 600 sec.'
        )
    parser.parse_args( namespace = config.args_ )
    init_serial()
    try:
        main( )
    except KeyboardInterrupt as e:
        print("[WARN] Interrupt from keyboard.... Quitting after cleanup.")
        cleanup()
        quit()
