#!/usr/bin/env python

from __future__ import print_function
    
__author__           = "Dilawar Singh"
__copyright__        = "Copyright 2016, Dilawar Singh"
__credits__          = ["NCBS Bangalore"]
__license__          = "GNU GPL"
__version__          = "1.0.0"
__maintainer__       = "Dilawar Singh"
__email__            = ""
__status__           = "Development"

import sys
import os
import socket 
import random
import time
import errno
import numpy as np
import cv2
from multiprocessing import Process, Array
import threading
import datetime
import re
import config
import arduino 
import readchar
from collections import defaultdict
import Queue
import logging
import gnuplotlib as gp

_logger = logging.getLogger('')

running_data_line_ = 0
total_trials_ = 0
cs_type_ = None
next_probe_in_ = -1
flipped_ = 0

select_sent_ = False

# Our shared queue used in multiprocessing
q_ = Queue.Queue()
running_trial_ = 0
finished_all_ = False

script_dir = os.path.dirname( os.path.realpath( __file__ ) )
config_file = os.path.join( script_dir, 'config.h' ) 
if not os.path.isfile( config_file ):
    print( "I can't find %s. Make sure it is available" % config_file )
    print( " Did you run cmake? " )
    quit( )

with open( config_file, "r" ) as cf:
    configText = cf.read( )
    h = re.search( r'#define\s+FRAME_HEIGHT\s+(\d+)', configText ).group(1)
    w = re.search( r'#define\s+FRAME_WIDTH\s+(\d+)', configText ).group(1) 
    sock = re.search( r'#define\s+SOCK_PATH\s+\"(.+?)\"', configText ).group(1) 
    h, w = int(h), int(w)
    assert sock, "Can't read socket path from configuration file"

sock_name_ = sock

img_shape_ = ( h, w )
frame_size_ = img_shape_[0] * img_shape_[1]

max_frames_in_trial = 1200
image_stack_ = None

now = datetime.datetime.now().isoformat( )
data_dir_ = 'videos_/%s' % now 

metadata_ = { 'acquisition_datetime' : [ ] }

# When True, put a small text on each frame.
write_data_ = True

current_data_line_ = Array( 'c', 200 )

if not os.path.isdir( data_dir_ ):
    os.makedirs( data_dir_ )

def trial_file_path( trialNum ):
    return os.path.join( config.save_dir_, 'Trial%s.csv' % trialNum )

def cleanup():
    global finished_all_
    finished_all_ = True
    config.serial_port_.write_msg( 'rr' )
    print("+++++++++++++++++++++++++++++ All over")
    

def append_trial_data( outfile, value, time, trialNum, cs, nextProbeIn ):
    with open(outfile, 'a') as f:
        f.write('%s,%s,%s,%s\n' % (value, time, cs, nextProbeIn))

def send_press_select( reftime, interval ):
    if time.time() - reftime < interval:
        return False
    _logger.info('Sending SELECT to board')
    config.serial_port_.write_msg("ss\r")
    time.sleep(0.5)
    _logger.info('[INFO] Waiting for Board to respond .', end='')
    sys.stdout.flush()
    while '>>>Recieved' not in config.serial_port_.read_line():
        print('.', end='')
        sys.stdout.flush()
    return True

def print_line( line, lock ):
    global running_data_line_
    ds = line.split(',')
    if len(ds) != 4:
        return 
    hline = '-'.join([ '' for x in range( min(80, int(ds[1])/10) ) ])
    # Only print if running data line is multiple of 10
    if running_data_line_ % 20 == 0:
        if lock:
            lock.acquire()
            _logger.info("%3s - %10s\n" % (line, hline ))
            lock.release()
        else:
            _logger.info("%3s - %10s\n" % (line, hline ))


def initialize_trial_file( trial_number ):
    trialFile = trial_file_path( trial_number )
    print('[INFO] Initializing a new trial file', end='')
    with open( trialFile, "w") as f:
        f.write("# Written on: %s\n" % datetime.datetime.now().isoformat())
        f.write("# mouse name : %s\n" % config.args_.name)
        f.write("# Session type : %s\n" % config.args_.session_type)
        f.write("# Session num : %s\n" % config.args_.session_num)
        f.write("# flipped : %s\n" % flipped_)
    print(".... Done")

    
def collect_data ( lock = None ): 
    """
    This function reads each from ardino and keeps them in a queue
    """
    global q_
    global running_data_line_
    global total_trials_
    global running_trial_
    global cs_type_ 
    global next_probe_in_
    global select_sent_ 
    tstart = time.time()
    runningTrial = 0
    while not finished_all_:
        running_data_line_ += 1
        line = config.serial_port_.read_line( )
        x, y, trialNum, totalTrials, cs, next_probe_in_ = line_to_data( line )
        total_trials_ = totalTrials
        if (x and y) is None:
            continue

        try:
            x, y = int(x), int(y)
            q_.put((y,x))
            config.trial_dict_[runningTrial].append((y,x))
        except Exception as e:
            pass

        # Valid trial has started.
        if trialNum != 0:
            break
        # All right. If we are here then we are waiting for SELECT to be
        # pressed. Let's press is by sending three ` to serialport after
        # some timeout.
        if send_press_select( tstart, config.args_.select_after ):
            if lock:
                lock.acquire()
            _logger.info("SELECT sent")
            if lock:
                lock.release()
            break

    # Either we have pressed the SELECT or we have sent the select command ss
    select_sent_ = True
    _logger.info('Out of first loop.')
    while not finished_all_:
        running_data_line_ += 1
        running_trial_ = runningTrial
        line = config.serial_port_.read_line()
        x, y, trialNum, totalTrials, cs_type_, next_probe_in_ = line_to_data(line)
        if (x and y) is None:
            continue
        q_.put((y,x))
        trialFile = trial_file_path( trialNum )
        append_trial_data(trialFile, y, x, trialNum, cs_type_, next_probe_in_)
        total_trials_ = totalTrials
        print_line( line, lock )
        if trialNum > runningTrial:
            outfile = trial_file_path( runningTrial )
            _logger.info("|| Wrote previous trial to %s" % outfile)
            _logger.info('== New Trial: :%s/%s, cs: %s' % (trialNum,
                totalTrials, cs_type_)
                )
            # Also initialize the new trial file.
            initialize_trial_file( trialNum )
            runningTrial = trialNum
        if runningTrial == totalTrials:
            # Exit
            cleanup()

def answer_questions( numbers = 5):
    # All great UI have four questions. Yes we have to, they all starts with
    # Please. Not three. Four. Sorry.
    questionsAnswered = [ ]
    for i in range( 20 ):
        l = arduino.read_until('?? Please', timeout = 1)
        if 'mouse name' in l:
            _logger.info('[ANSW] %s = %s' % (l, config.args_.name))
            config.serial_port_.write_msg('%s\r' % config.args_.name )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        elif 'session type' in l:
            _logger.info('[ANSW] %s = %s' % (l, config.args_.session_type))
            config.serial_port_.write_msg( '%s\r' % config.args_.session_type )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        elif 'session number' in l:
            _logger.info('[ANSW] %s = %s' % (l, config.args_.session_num))
            config.serial_port_.write_msg('%s\r' % config.args_.session_num )
            time.sleep(0.5)
            if l not in questionsAnswered:
                questionsAnswered.append(l)
        elif  'want to flip' in l:
            _logger.info('[ANSW] %s = %s' % (l, config.args_.flipped))
            config.serial_port_.write_msg('%s\r' % config.args_.flipped)
            time.sleep(0.5)
            flipped_ = 1
            if l not in questionsAnswered:
                questionsAnswered.append( l )
        elif 'CS Fraction' in l:
            _logger.info("[ANSW] %s = %s " % (l, config.args_.cs_fraction))
            config.serial_port_.write_msg( '%s\r' % config.args_.cs_fraction)
            time.sleep( 0.5 )
            if l not in questionsAnswered:
                questionsAnswered.append( l )
        else:
                pass

        if len(questionsAnswered) == numbers:
            _logger.info('[INFO] All questions are answered')
            return 


def init( ):
    """
    Wait for first four questions to appear which requires writing to serial
    port. If serial port is sending legal data then continue, questions are
    probably answered.
    """

    # Get 4 lines from arduino, and check if arduino is sending legal data or
    # just waiting for questions to be answered.
    for i in range(4):
        l = config.serial_port_.read_line( )
        while not l:
            l = config.serial_port_.read_line( )
        if 'please' in l.lower():
            # mere sawalo ka jawav do... do naa!
            answer_questions(  )
            break
        # If valid data is found in lines (trial is more than 1) then don't ask
        # questions and quit immediately
        else:
            data = line_to_data( l )
            if data[2] is not None:
                if data[2] >= 0:
                    break

    now = datetime.datetime.now()
    timeStamp =  now.strftime('%Y-%m-%d_%H-%M-%S')
    mouseName = 'Mouse%s' % config.args_.name
    outdir = os.path.join( mouseName
            , 'Mouse%s_SessionType%s_Session%s' % ( 
                config.args_.name, config.args_.session_type, config.args_.session_num)
            )

    config.save_dir_ = os.path.join( config.save_dir_, outdir )
    if os.path.exists(config.save_dir_):
        config.save_dir_ = os.path.join(config.save_dir_, timeStamp)
        os.makedirs(config.save_dir_)
    else:
        os.makedirs(config.save_dir_) 

def send_command( ):
    # all commands should be two characters long
    # This function must be last one after all the threads/processes have been
    # launched.
    global select_sent_
    global finished_all_
    lock = None
    command = ""
    legalCommandsBeforeStart = [ "11", "22", "pp", "ss" ]
    legalCommandsAfterStart = [ "rr", "ww", "cc" ]
    validCommands = legalCommandsAfterStart + legalCommandsBeforeStart 
    validStartChars = ''.join([ x[0] for x in validCommands ])
    print( 'Executing send command loop' )
    while True:
        # This is blocking.
        k = readchar.readkey()
        if k in validStartChars:
            command += k
            if command in legalCommandsBeforeStart and not select_sent_:
                _logger.info("[COMMAND] Sending command: %s" % command)
                config.serial_port_.write_msg( command )
                command = ""
            # Last two commands needs to be handled separately.
            elif command == 'ss' and (not select_sent_):
                select_sent_ = True
                config.serial_port_.write_msg( command )
            elif command == 'rr':
                # reboot. 
                _logger.warn("Reboot in 2 seconds. You have to relaunch the app")
                config.serial_port_.write_msg( command )
                finished_all_ = True
                raise KeyboardInterrupt
            elif (command in legalCommandsAfterStart) and select_sent_:
                _logger.info("[COMMAND] Sending command (after start): %s" % command)
                config.serial_port_.write_msg( command )
                command = ""
            else:
                if(len(command) == 2):
                    _logger.info("Did not send :%s, select_sent_ %s" % (
                        command, select_sent_)
                        )
            if len(command) == 2:
                command = ""
        elif k in [ '\x03', '\x04', '\x1a' ]:
            finished_all_ = True
            break

def init_serial( baudRate = 38400):
    if config.args_.port is None:
        config.args_.port = arduino.get_default_serial_port( )
    _logger.info("Using port: %s" % config.args_.port)
    config.serial_port_ = arduino.ArduinoPort( config.args_.port, baudRate )
    config.serial_port_.open( wait = True )

def line_to_data( line ):
    global current_data_line_
    now  = datetime.datetime.now( ).isoformat( )
    current_data_line_.value = now + '|' + line
    if not line.strip():
        data = [None]*6
    try:
        data = [ int(x) for x in line.split(',') ]
    except Exception as e:
        data = [None]*6
    if len(data) != 6:
        _logger.debug("Invalid line: %s" % line)
        data = [None]*6
    return data

def plot_data( lock ):
    global q_
    global running_trial_
    global total_trials_
    global cs_type_, next_probe_in_
    ptstart = time.time()
    while True:
        if finished_all_ == 1:
            return None
        # Queue can become empty in ITI sessions.
        qsize = q_.qsize( )
        if qsize < 20:
            # _logger.debug('Queue  size less than 20')
            continue
        # Get some elements from queue and plot them.
        for i in range(10):
            d = q_.get()
            config.ybuff_.append( int(d[0]) )
        
        title = '%s %2.2f, Mouse: %s, Trial: %2d/%3d, CS: %s, next probe in: %s' % ( 
                config.args_.port
                , time.time() - ptstart 
                , config.args_.name
                , running_trial_
                , total_trials_
                , cs_type_
                , next_probe_in_
                )

        gp.plot( np.asarray(config.ybuff_[-2000:]) 
                , title = title
                , terminal = 'x11'
                , yrange = '200:800'
                )


def save_img_stack( index ):
    import tifffile
    global metadata_ 
    global image_stack_ 
    filename = os.path.join( data_dir_, 'stack_%03d.tif' % index )
    tifffile.imsave( filename, image_stack_, metadata = metadata_ )
    print( '[INFO] Saved to %s' % filename )


def init_stack( ):
    global image_stack_
    global img_shape_, max_frames_in_trial 
    global metadata_ 
    metadata_[ 'acquisition_datetime' ] = []
    image_stack_ = np.zeros( 
            shape=( max_frames_in_trial, img_shape_[0], img_shape_[1] )
            , dtype = np.uint8
            )


def poll_socket( ):
    return os.path.exists( sock_name_ )


def arduino_client( ):
    """Client for arduino

    IT launches two threads, one listens to keyboard command and other for the
    data. This also update a global variable current_data_line_ which is read by
    camera client.
    """
    collect_data( )

def show_frame( frame ):
    cv2.imshow( 'frame', frame )
    cv2.waitKey( 1 )

def camera_client( ):
    global finished_all_
    global current_data_line_
    global img_, buf_
    global image_stack_
    s = socket.socket( socket.AF_UNIX, socket.SOCK_STREAM )

    while not finished_all_:
        if os.path.exists( sock_name_ ):
            try:
                s.connect( sock_name_ )
                break
            except Exception as e:
                print( 'Error connecting %s' % e )
                time.sleep( 1 )
        else:
            print( 'Could not find %s' % sock_name_ )
            time.sleep( 1 )

    # print( s.getsockopt( socket.SOL_SOCKET, socket.SO_SNDBUF ) )
    # Make it non-blocking.
    # fcntl.fcntl( s, fcntl.F_SETFL, os.O_NONBLOCK )
    totalBytesRead = 0
    totalFrames = 0
    buf = ''
    init_stack( )
    framesInStack = 0
    trial_count = 0
    while not finished_all_:
        try:
            data = s.recv( frame_size_ )
            buf += data
            if len( buf) >= frame_size_:
                img = np.frombuffer( buf[:frame_size_], dtype = np.uint8 )
                img = np.reshape( img, img_shape_ )
                if write_data_:
                    cv2.putText( img, current_data_line_.value, (0, 10)
                            , cv2.FONT_HERSHEY_SIMPLEX, 0.4, 0, 1
                            )
                # print( img.shape, img.max(), img.min(), len(img) )
                show_frame( img )
                image_stack_[ framesInStack ] = img
                metadata_[ 'acquisition_datetime' ].append( now )
                framesInStack += 1
                buf = buf[frame_size_:]
            else:
                pass

        except Exception as e:
            err = e.args[0]
            if err == errno.EAGAIN or err == errno.EWOULDBLOCK:
                time.sleep( 0.1 )
                print( 'No data available' )
                continue
            else:
                print('No data : %s' % e )
                break

        if framesInStack == max_frames_in_trial :
            framesInStack = 0
            tiff = image_stack_
            print( "\nSize of image stack ", tiff.shape )
            save_img_stack( trial_count )
            trial_count += 1
            init_stack( )

def main( ):
    # Lock so that only one process prints to console at a time.
    # When daemon is set to True, all threads will exit (ungracefully) when main
    # terminates.
    global finished_all_

    init( );
    print( 'Initialized arduino board' )

    cam = Process( target = camera_client, args=() )
    cam.daemon = True
    cam.start( )
    print( 'Camera client launched' )

    arduinoP = Process( target = arduino_client, args=())
    arduinoP.daemon = True
    arduinoP.start( )
    print( "Arduino client launched" )

    try:
        send_command( )
    except Exception as e:
        print( 'Got %s in send_comamnd' % e )
        finished_all_ = True
        raise KeyboardInterrupt

    arduinoP.join( )
    cam.join( )
    print( 'All done' )

if __name__ == '__main__':
    import argparse
    description = '''Recieve data from serial port and camera as well.'''
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('--name', '-n'
        , required = True
        , type = str
        , help = 'Mouse name (string)'
        )
    parser.add_argument('--session-type', '-st'
        , required = True
        , type = int
        , help = 'Seession Type [0 to 11]'
        )
    parser.add_argument('--session-num', '-sn'
        , required = True
        , type = int
        , help = 'Session number (positive integer)'
        )
    parser.add_argument('--port', '-p'
        , required = False
        , default = None
        , help = 'Serial port [full path]'
        )
    parser.add_argument('--select_after', '-sa'
        , required = False
        , default = 60000000.0
        , type = float
        , help = 'Press SELECT after time. Default 600 sec.'
        )
    parser.add_argument('--flipped', '-f'
        , required = False
        , default = 0
        , type = int
        , help = 'Wheather CS+/CS- are to be flipped (0/1 (False,True)'
        )
    parser.add_argument('--cs_fraction', '-cf'
        , required = False
        , default = 10
        , type = int
        , help = 'CS fraction'
        )
    parser.parse_args( namespace = config.args_ )
    init_serial( )
    # Intialize logger after intializing serial port.
    config.init_logger( filename = 
            'blink_%s.log' % config.args_.port.split('/')[-1]
            )
    try:
        main( )
    except KeyboardInterrupt as e:
        _logger.warn("Interrupt from keyboard.... Quitting after cleanup.")
        cleanup()
        quit( 1 )
